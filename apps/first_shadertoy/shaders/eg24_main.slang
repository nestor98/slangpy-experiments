
// Auto-generated Slang compute wrapper for Shadertoy-style fragment code

struct ShadertoyGlobals
{
    RWTexture2D<float4> output;
    float u_iTime;
    float2 u_iResolution;
    float4 u_iMouse;
    Texture2D u_iChannel0;
    Texture2D u_iChannel1;
    Texture2D u_iChannel2;
    Texture2D u_iChannel3;
};

// User code injected below. It should reference u_iTime, u_iResolution, u_iMouse, and u_iChannel*.
#define USER_HAS_MAINIMAGE 1
#line 1
// This shader is an example application implementing Real-Time Underwater Spectral Rendering 
// [https://doi.org/10.1111/cgf.15009]
// The scene geometry and base lighting is a fork of iq's https://www.shadertoy.com/view/Xds3zN

// The method renders a number of natural waters using measured spectral coefficients (see Common tab)
// (scattering, extinction and diffuse downwelling attenuation coefficient, Kd)
// You can set the Jerlov water type at the start of this file (0 to 5, from least to most turbid)
// by default, it changes with time

// Here the scene geometry is raymarched, but the inscattering only needs the scene distance, so 
// it can be used in a rasterization pipeline

// For spatially varying volumetric single scattering, in the paper we used froxel lighting.
// Here, we use raymarching instead (slower but simpler). 
// ------------------------------------------------------------------------------
// NOTE: I disabled SS by default but I recommend to enable it if you can (line 43)!
// ------------------------------------------------------------------------------

// More credits:
// The caustics here are from Dave Hoskins (https://www.shadertoy.com/view/MdlXz8)
// The dithering (very important to avoid banding) is from https://www.shadertoy.com/view/4dcSRX and 
// https://www.shadertoy.com/view/Md3SRX, which were adapted from valve's GDC15 talk by alex vlachos

//------------------------------------------------------------------
// The water types are 0.0 to 5.0 (three open, three coastal, from less turbid to more turbid)
// Uncomment to animate the water type:
#define ANIMATE_WATER_TYPE
const float JERLOV_WATER_IDX = 0.; // if the above is commented, this sets the water type (0 to 5)

// Alternatively the depth of the scene changes w/time
// #define ANIMATE_DEPTH 

//------------------------------------------------------------------
// Performance:

// Volumetric SS:
// 0-> Disabled (cheapest..)
// 1-> Brute force
#if HW_PERFORMANCE==0
#define SINGLE_SCATTERING 0
#else
// --------------------------------------------------------------
#define SINGLE_SCATTERING 0    // change this to 1 if you can
// --------------------------------------------------------------
#endif
// Single scattering (volumetric shadows&caustics etc): 
#if SINGLE_SCATTERING == 1
// You can tune the SS settings here:
// A ray will be marched from the origin to the minimum of intersection point and ss_dist, 
// evaluating lighting at ss_steps steps along the way (it would be nice to do this at a quarter res or so)
const int ss_steps = 40; // can be increased to reduce some artifacts... for a price
const float ss_dist = 4.; // maximum range for ss
const float ss_multiplier = 0.0004; // multiplier for the strength of ss
const float ss_caustics_mult = 1.; // multiplier for the caustics in ss
#endif

//------------------------------------------------------------------
// 0-> no caustics
// 1-> one caustic texture
// 2-> two caustic textures (nicer, more cost) (animated differently to hide repetitions)
// 3-> 2 and, if SS is enabled, it also shades the volumetric caustics
#if HW_PERFORMANCE==0
#define CAUSTICS 1 
#else
#define CAUSTICS 3   
#endif

//------------------------------------------------------------------
// Scene lighting settings:

// scene depth (m below the surface):
#ifndef ANIMATE_DEPTH
#define SCENE_DEPTH 25. 
#else
#define SCENE_DEPTH 25. + 5. + 10.*sin(u_iTime* 1.)
//5.*sin(u_iTime)
#endif
const float turbidity = .9; // Multiplier of the water coefs (10x coefs is the same as the whole scene being 10x scale)

const vec3 sun_dir = vec3(-0.5, 1.4, -0.6);
const float sun_power = 40.;
const float exposure = 2.5;

// Spectral sampling (fast diminishing results):
const int samples = 8;

const float MAX_DIST_INSCATTERING = 1000.; // only for the analytical approx - no cost 

#if CAUSTICS > 0
const float caustic_power = 9.0;
const int caustic_iters = 4;
const float caustic_speed = 1.1;
const float caustic_freq = 1.2; // spatial freq of caustics
#endif


#define SPLIT_CHECK if (uv.x>u_iMouse.x/u_iResolution.x) 


//------------------------------------------------------------------
// ---------------------------------------------------------------------------
// Implements Eq 9 https://doi.org/10.1111/cgf.15009
// (Note: unlike in the paper here y points up)
// samples: nb of spectral samples
// range: min and max wls
// irradiance_in: the irradiance at the water surface
// o: origin of the ray (water surface assumed to be at the origin)
// w: direction of the ray, must be normalized
// dist: distance to the intersection (inscattering will be computed between o and o+w*dist)
// (Note: it would be nice to multiply the spectra with D65, the daylight spd. Right now it is 
//  illuminated by a constant spectrum (float irradiance_in). This works as a cloudy day I guess)
vec3 integrate_L_anim(int samples, vec2 range, float irradiance_in,
                vec3 o, vec3 w, float dist, float turbidity,
                float water_type) {
    float o_depth = -o.y; // depth of the origin underwater
    float cosine = -w.y;  // cosine of the direction (positive pointing down) 
    
    vec3 col = vec3(0.);
    for (int i=0;i<samples;i++) {
        float x = (float(i)+0.5)/float(samples); // important to center the samples if using few
        float wl = mix(range.x, range.y, x);
        
        vec3 props = turbidity * get_optical_props_anim(wl, water_type); // scat, ext, kd
        float b = props.x, c = props.y, kd = props.z; // Unpack the coefs
        
        float floor_refl = 0.; // TODO: add reflectance from floor (now infinitely deep.. or completely black)
        float c_mod = c + kd*cosine; // modified c with kd:
        
        // Eq 9 in the paper (sigma_s=b; sigma_t=c):
        float L = (b * irradiance_in) * (1. - exp(-dist*c_mod)) 
                  * (exp(-kd*o_depth) + floor_refl) / (4.*PI*c_mod);
                  
        vec3 sens = sensitivity(wl);
        col += L*sens;
    }
    col /= float(samples);
    return col;
}

const float TAU = 6.28318530718;

// Very nice tileable caustics
// from @DaveHoskins https://www.shadertoy.com/view/MdlXz8
float caustic(in vec2 p, in float time) {
	time = time * .5+23.0;

	vec2 i = vec2(p);
	float c = 1.0;
	float inten = .005;
    
	for (int n = 0; n < caustic_iters; n++) 
	{
		float t = time * (1.0 - (3.5 / float(n+1)));
		i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
		c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));
	}
	c /= float(caustic_iters);
	c = 1.17-pow(c, 1.4);
    return pow(abs(c), 8.0);
}


float getCaustics(vec3 p, vec3 sunDir) {
    float t_surf = (10.0-p.y)/sunDir.y; // dist to water surface
    if( t_surf<=0.0 ) return 0.; // above water?
    vec3 p_surf = p + sunDir*t_surf;
    p_surf *= 0.11 * caustic_freq;
    
    vec2 uv =  mod(u_iTime+p_surf.xz*TAU*2.0, TAU)-250.0; 
    float c = caustic(uv, u_iTime*caustic_speed);     
#if CAUSTICS > 1
    // add a second texture, offset and with slightly diff parameters: 
    uv =  mod(-vec2(0.4,0.7)*u_iTime+p_surf.xz*TAU*2.0*0.56, TAU)-250.0;  
    c += 1.1 * caustic(uv, u_iTime*caustic_speed*1.1); 
#endif
    return c * caustic_power;
}


// This just returns an id between 0. and 5. which is one of the water types.
// (Float values in between interpolate the two neighboring waters, e.g., 0.5 is a mix of Jerlov IB and II)
// If ANIMATE_WATER_TYPE is set, it loops between them
// otherwise this returns JERLOV_WATER_IDX
float get_water_type() {
    #ifndef ANIMATE_WATER_TYPE
    return JERLOV_WATER_IDX;
    #else
    // note: removed the last water here bc it is very very turbid
    //return 5.-abs(mod((u_iTime*0.6), 10.)-5.); 
    return 4.-abs((mod((u_iTime*0.6), 8.)-4.)); 
    #endif
}

// -----------------------------------------------------------------

// AA from iq's shader:
#define ZERO (min(iFrame,0))
#if HW_PERFORMANCE==0
#define AA 1
#else
#define AA 1   // make this 2 or 3 for antialiasing
#endif


// -------------------------------------------------------------------------------------------------
// Dithering:
// Dithering is important because water produces very smooth gradients that are quite visible with
// 255 bits. You can turn it off (or try DITHER_TEST) to check it out (espetially visible in more turbid waters)
#define DITHER 1
// 0-> none; 1-> https://www.shadertoy.com/view/Md3SRX

// For comparison, enable this so that mouse.x controls where dither is enabled:
//#define DITHER_TEST 

// from valve's GDC15 talk by alex vlachos, implemented by 
// https://www.shadertoy.com/view/4dcSRX and https://www.shadertoy.com/view/Md3SRX
vec3 ScreenSpaceDither(vec2 vScreenPos)
{
    vec3 vDither = vec3(dot(vec2(131.0, 312.0), vScreenPos.xy + u_iTime));
    vDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0)) - vec3(0.5, 0.5, 0.5);
    return 0.05*(vDither.rgb / 15.0);
}


vec2 intersectWaterSurface(vec3 ro, vec3 ld) {
    vec2 res = vec2(-1.0,-1.0); // (distance, id={-1 not found, 1 found water )
    float tp1 = (0.0-ro.y)/-ld.y;
    if( tp1>0.0 )
    {
        res = vec2( tp1, 1.0 );
    }
    return res;
}

float upsample(vec3 col, float wl) {
    //Low budget version of spectral upsampling (something like this [https://rgl.epfl.ch/publications/Jakob2019Spectral] would be better)
    if (wl<480.) return col.b; 
    else if (wl<560.) return col.g;
    else return col.r;
}

// Calculate the full SS at ro in direction rd, up to t units away
// for a light from ld
vec3 calcSS(in vec3 ro, in vec3 rd, in vec3 ld, float t, float turbidity, vec2 uv) {
    #if SINGLE_SCATTERING == 1
    t = min(t,ss_dist);
    float water_type = get_water_type();
    vec3 l_ss = vec3(0.);
    // ss is already expensive, so dont make it spectral:
    float ext = get_optical_props_anim(550., water_type).y;
    
    for (int i=1; i<ss_steps+1; i++) {
        float t_step = (-0.5 + t * float(i)) / float(ss_steps);
        
        // vec3 p = mix(ro, ro+rd*t, float(i)/float(ss_steps));
        vec3 pos = ro+ rd*t_step;

        float shadow = calcSoftshadow( pos, ld, 0.02, 2.5 );
        vec2 water_surf = intersectWaterSurface( pos, ld );
        if (water_surf.y<0.) water_surf.y *=-1.;//return 0.*vec3(1.,0.,1.); // Not found
        
        float t_surface = water_surf.x; // Distance to water surface
        
        float l_caustic = 1.;
        #if CAUSTICS > 2
        // get caustics here for nice godrays
        l_caustic = 0.2 * getCaustics(pos, ld);
        l_caustic = ss_caustics_mult*1.*pow(l_caustic, 5.);
        #endif
        
        if (shadow>0.2) {
            float transmittance = exp(-(t_surface + t_step) * ext); // extinction
            l_ss += vec3(0.4,0.6,0.8) * shadow * (sun_power*l_caustic) 
                  * transmittance;         
        }
    }
    return l_ss * ss_multiplier /float(ss_steps);
    
    #endif
    return vec3(0.,0.,0.);
}

vec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, vec2 uv )
{ 

    float water_type = get_water_type();
    // make the last waters less turbid for visualization in this scene:
    float turbidity_mod = mix(turbidity, turbidity/6., water_type/6.);
   
    // background
    vec3 col = vec3(0.);
        
    // raycast scene
    vec2 res = raycast(ro,rd);
    float t = res.x; // dist
	float m = res.y; // Material
    
    if (m>-0.5) {
    	vec3 lin = vec3(0.0);

        vec3 pos = ro + t*rd;
        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );
        vec3 ref = reflect( rd, nor );
        
        // material        
        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );
        float ks = 1.0;
        
        if( m<1.5 )
        {
            // project pixel footprint into the plane
            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);
            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);

            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );
            col = 0.15 + f*vec3(0.05);
            ks = 0.4;
        }

        // lighting
        float occ = calcAO( pos, nor );
        
        { // surface shading, adapted from iq's
            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));
                  dif *= occ;
            float spe = smoothstep( -0.2, 0.2, ref.y );
                  spe *= dif;
                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );
                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );
            #if CAUSTICS > 0
            vec3  lig = normalize( sun_dir );
            //vec3  hal = normalize( lig-rd );
            float dif2 = clamp( dot( nor, lig ), 0.0, 1.0 );
                  dif2 *= calcSoftshadow( pos, lig, 0.02, 2.5 );
            float c = getCaustics(pos, lig);
            dif += dif2 * c * 0.8;
            spe = spe * (1. + c*c*0.4);//sharpened specular caustics
            #endif
            
            float pos_depth = -pos.y + SCENE_DEPTH;

            float wl_step = (700.-400.)/float(samples);
            for (float wl=400.+wl_step*0.5; wl<700.; wl+=wl_step) {
                vec3 b_c_kd = turbidity_mod*get_optical_props_anim(wl, water_type); // turbidity is a multiplier for artistic control
                float l_wl = (upsample(col, wl) * 0.9 * dif  // Diffuse
                             + .9*spe*ks)
                             * exp(-b_c_kd.z * pos_depth) * // diffuse extinction (kd) from water surface to pos
                               exp(-b_c_kd.y * t );      // extinction (c) from pos to ro (t units)
                lin += sensitivity(wl) * l_wl;
            }
            lin /= float(samples);
        }
       col = lin;
    }

    // -------------------------------------------------------------
    // water
    t = min(t, MAX_DIST_INSCATTERING);
    
    // MS lighting:
    col += integrate_L_anim(samples, vec2(400.,700.), sun_power*1., 
            ro-vec3(0.,SCENE_DEPTH,0.), 
            normalize(rd), t, 
            turbidity_mod, water_type);
            
    // Single scattering, if enabled:
    col += calcSS(ro, normalize(rd), normalize(sun_dir), t, turbidity_mod, uv );
    
	return col;
}

void user_mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 mo = u_iMouse.xy/u_iResolution.xy;
	float time = 32.0 + u_iTime*1.5;

    // camera	
    
    // move target
    vec3 ta = vec3( 0.25, mix(1.6, -1.05, 1.-mo.y), -0.75 );
    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.4, 4.5*sin(0.1*time + 7.0*mo.x) );
    ro.y = mix(ro.y, ta.y+2.2, mo.y);
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, 0. );

    vec3 tot = vec3(0.0);
#if AA>1
    for( int m=ZERO; m<AA; m++ )
    for( int n=ZERO; n<AA; n++ )
    {
        // pixel coordinates
        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;
        vec2 p = (2.0*(fragCoord+o)-u_iResolution.xy)/u_iResolution.y;
#else    
        vec2 p = (2.0*fragCoord-u_iResolution.xy)/u_iResolution.y;
#endif
        // focal length
        const float fl = 2.5;
        
        // ray direction
        vec3 rd = ca * normalize( vec3(p,fl) );

         // ray differentials
        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-u_iResolution.xy)/u_iResolution.y;
        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-u_iResolution.xy)/u_iResolution.y;
        vec3 rdx = ca * normalize( vec3(px,fl) );
        vec3 rdy = ca * normalize( vec3(py,fl) );
        
        // render	
        vec3 col = render( ro, rd, rdx, rdy, fragCoord.xy/u_iResolution.xy);

        // gain
        col = col*3.0/(2.5+col);
        
		// gamma
        //col =pow( col, vec3(0.4545) );
        //col = gamma_correct(exposure*col); // apply gain for this one
        col = aces_approx(exposure*col);

        tot += col;
        
#if AA>1
    }
    tot /= float(AA*AA);
#endif

#if DITHER > 0
    // Dither to avoid banding (see https://www.shadertoy.com/view/XdtXWn)
    // could be done to the params instead (e.g. inscattering distance or angle)
    #ifdef DITHER_TEST
    vec2 uv = fragCoord.xy/u_iResolution.xy;
    bool dither = uv.x < u_iMouse.x/u_iResolution.x;
    tot *= smoothstep(0.,1.,abs(uv.x-u_iMouse.x/u_iResolution.x)*1000.);
    #else
    bool dither = true;
    #endif
    if (dither) tot += ScreenSpaceDither(fragCoord);
#endif
    
    fragColor = vec4( tot, 1.0 );
}


[compute]
void compute_main(uint3 tid : SV_DispatchThreadID, ShadertoyGlobals g_shadertoy)
{
    uint2 uv_i = uint2(tid.xy);
    float2 fragCoord = float2(uv_i.x, uv_i.y);

    float4 outCol = float4(0,0,0,1);

    #if defined(USER_HAS_MAINIMAGE)
        user_mainImage(outCol, fragCoord);
    #elif defined(USER_HAS_MAIN_RET)
        outCol = user_main(fragCoord);
    #endif

    g_shadertoy.output[uv_i] = outCol;
}
